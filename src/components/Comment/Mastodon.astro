---
interface Props {
  statusId: string
  instanceUrl: string
  username?: string
}

const { statusId, instanceUrl, username } = Astro.props

// Build the Mastodon post URL
// If username is provided, use it to create direct link
// Otherwise, just link to the instance
const mastodonPostUrl = username
  ? `${instanceUrl}/@${username}/${statusId}`
  : instanceUrl
---

<div id="mastodon-comments" class="no-heti mt-16">
  <div class="mastodon-header mb-6">
    <h3 class="mb-2 text-lg c-primary font-bold">Comments</h3>
    <p class="text-sm c-secondary">
      Join the conversation on <a
        href={mastodonPostUrl}
        target="_blank"
        rel="noopener noreferrer"
        class="mastodon-link"
                               >
        Mastodon
      </a>
    </p>
  </div>

  <div id="mastodon-comments-list" class="space-y-4">
    <div class="mastodon-loading c-secondary">Loading comments...</div>
  </div>
</div>

<script is:inline define:vars={{ statusId, instanceUrl }}>
async function loadMastodonComments() {
  const container = document.getElementById('mastodon-comments-list')
  if (!container || !statusId || !instanceUrl)
    return

  try {
    const apiUrl = `${instanceUrl}/api/v1/statuses/${statusId}/context`
    const response = await fetch(apiUrl)

    if (!response.ok) {
      throw new Error(`Failed to fetch comments: ${response.status}`)
    }

    const data = await response.json()
    const comments = data.descendants.filter(
      comment => comment.in_reply_to_id === statusId,
    )

    if (comments.length === 0) {
      container.innerHTML = `
          <div class="mastodon-no-comments c-secondary text-sm">
            No comments yet. Be the first to comment on Mastodon!
          </div>
        `
      return
    }

    // Build comment tree
    function buildCommentTree(allComments, parentId) {
      const replies = allComments.filter(
        comment => comment.in_reply_to_id === parentId,
      )

      return replies.map((reply) => {
        const nestedReplies = buildCommentTree(allComments, reply.id)
        return nestedReplies.length > 0
          ? { ...reply, replies: nestedReplies }
          : reply
      })
    }

    const commentTree = buildCommentTree(data.descendants, statusId)

    // Render comments
    function renderComment(comment, level = 0) {
      const indent = level > 0 ? `style="margin-left: ${level * 1.5}rem"` : ''
      const avatar = comment.account.avatar
      const displayName = comment.account.display_name || comment.account.username
      const username = comment.account.acct
      const date = new Date(comment.created_at).toLocaleDateString(undefined, {
        year: 'numeric',
        month: 'short',
        day: 'numeric',
      })

      let html = `
          <div class="mastodon-comment" ${indent}>
            <div class="mastodon-comment-header">
              <img src="${avatar}" alt="${displayName}" class="mastodon-avatar" />
              <div class="mastodon-comment-meta">
                <div class="mastodon-comment-author">
                  <a href="${comment.account.url}" target="_blank" rel="noopener noreferrer" class="mastodon-link">
                    <strong>${displayName}</strong>
                  </a>
                  <span class="mastodon-username">@${username}</span>
                </div>
                <div class="mastodon-comment-time">
                  <a href="${comment.url}" target="_blank" rel="noopener noreferrer" class="mastodon-link">
                    ${date}
                  </a>
                </div>
              </div>
            </div>
            <div class="mastodon-comment-content">
              ${comment.content}
            </div>
            <div class="mastodon-comment-stats">
              ${comment.replies_count > 0 ? `<span>üí¨ ${comment.replies_count}</span>` : ''}
              ${comment.reblogs_count > 0 ? `<span>üîÅ ${comment.reblogs_count}</span>` : ''}
              ${comment.favourites_count > 0 ? `<span>‚≠ê ${comment.favourites_count}</span>` : ''}
            </div>
          </div>
        `

      if (comment.replies && comment.replies.length > 0) {
        html += comment.replies
          .map(reply => renderComment(reply, level + 1))
          .join('')
      }

      return html
    }

    container.innerHTML = commentTree.map(comment => renderComment(comment)).join('')
  }
  catch {
    container.innerHTML = `
        <div class="mastodon-error c-secondary text-sm">
          Failed to load comments. Please try again later.
        </div>
      `
  }
}

let observer = null

function setupMastodonComments() {
  observer?.disconnect()

  const container = document.getElementById('mastodon-comments')
  if (!container)
    return

  observer = new IntersectionObserver(
    (entries) => {
      if (entries.some(entry => entry.isIntersecting)) {
        loadMastodonComments()
        observer?.disconnect()
      }
    },
    { rootMargin: '500px' },
  )

  observer.observe(container)
}

function cleanup() {
  observer?.disconnect()
  observer = null
}

document.addEventListener('astro:page-load', setupMastodonComments)
document.addEventListener('astro:before-swap', cleanup)
setupMastodonComments()
</script>

<style is:global>
  #mastodon-comments {
    color: oklch(var(--un-preset-theme-colors-secondary));
  }

  #mastodon-comments .mastodon-header h3 {
    color: oklch(var(--un-preset-theme-colors-primary));
  }

  #mastodon-comments .mastodon-link {
    color: oklch(var(--un-preset-theme-colors-primary));
    text-decoration: none;
    transition: opacity 0.2s;
  }

  #mastodon-comments .mastodon-link:hover {
    opacity: 0.7;
  }

  #mastodon-comments .mastodon-comment {
    padding: 0.85rem 1rem;
    margin-bottom: 0.75rem;
    border-radius: 0.85rem;
    background-color: oklch(var(--un-preset-theme-colors-secondary) / 0.06);
    border: 1px solid oklch(var(--un-preset-theme-colors-secondary) / 0.16);
  }

  #mastodon-comments .mastodon-comment-header {
    display: flex;
    gap: 0.75rem;
    margin-bottom: 0.75rem;
  }

  #mastodon-comments .mastodon-avatar {
    width: 40px;
    height: 40px;
    border-radius: 9999px;
    flex-shrink: 0;
  }

  #mastodon-comments .mastodon-comment-meta {
    flex: 1;
    min-width: 0;
  }

  #mastodon-comments .mastodon-comment-author {
    display: flex;
    align-items: baseline;
    gap: 0.5rem;
    margin-bottom: 0.1rem;
    font-size: 0.9rem;
  }

  #mastodon-comments .mastodon-comment-author strong {
    font-weight: 600;
  }

  #mastodon-comments .mastodon-username {
    color: oklch(var(--un-preset-theme-colors-secondary) / 0.7);
    font-size: 0.8rem;
  }

  #mastodon-comments .mastodon-comment-time {
    font-size: 0.8rem;
    color: oklch(var(--un-preset-theme-colors-secondary) / 0.7);
  }

  #mastodon-comments .mastodon-comment-content {
    margin-top: 0.4rem;
    line-height: 1.6;
    font-size: 0.95rem;
  }

  #mastodon-comments .mastodon-comment-content p {
    margin: 0 0 0.4rem;
  }

  #mastodon-comments .mastodon-comment-content img,
  #mastodon-comments .mastodon-comment-content video,
  #mastodon-comments .mastodon-comment-content iframe {
    display: block;
    max-width: 210px;
    max-height: 210px;
    width: 100%;
    border-radius: 0.75rem;
    margin: 0.5rem 0 0.25rem;
    object-fit: cover;
  }

  #mastodon-comments .mastodon-comment-content figure,
  #mastodon-comments .mastodon-comment-content .status-card {
    margin: 0.5rem 0 0.25rem;
    max-width: 210px;
    border-radius: 0.75rem;
    overflow: hidden;
  }

  #mastodon-comments .mastodon-comment-content .status-card img {
    max-width: 100%;
    height: auto;
  }

  #mastodon-comments .mastodon-comment-content a {
    color: oklch(var(--un-preset-theme-colors-primary));
    text-decoration: none;
  }

  #mastodon-comments .mastodon-comment-content a:hover {
    text-decoration: underline;
  }

  #mastodon-comments .mastodon-comment-stats {
    display: flex;
    gap: 1rem;
    margin-top: 0.35rem;
    font-size: 0.8rem;
    color: oklch(var(--un-preset-theme-colors-secondary) / 0.7);
  }

  #mastodon-comments .mastodon-loading,
  #mastodon-comments .mastodon-no-comments,
  #mastodon-comments .mastodon-error {
    padding: 1rem;
    text-align: center;
  }

  #mastodon-comments .mastodon-error {
    color: oklch(0.6 0.15 20);
  }
</style>
